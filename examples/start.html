{% extends "base.html" %}
{% set title = "Start" %}
{% block content %}
<p>
    Na starcie chciaÅ‚bym zaznaczyÄ‡, Å¼e przykÅ‚ady sÄ… dla poczatkujÄ…cych programistÃ³w obojÄ™tnego jÄ™zyka,
    ktÃ³rzy majÄ… pojÄ™cia co to sÄ… zmienne, stringi oraz pÄ™tle.
</p>
<p>
    W kilku przykÅ‚adach zamierzam pokazaÄ‡ jak dziaÅ‚a pamiÄ™Ä‡ w programach w bardzo podstawowym zakresie.
    Odrazu chciaÅ‚bym zaznaczyÄ‡, Å¼e implementacja pamiÄ™ci moÅ¼e siÄ™ znacznie rÃ³Å¼niÄ‡ w innych architekturach,
    wiÄ™c przykÅ‚ady nie bÄ™dÄ… odzwierciedlaÅ‚y rzeczywistego dziaÅ‚ania - moÅ¼emy uznaÄ‡, Å¼e dla <i>dobra</i>
    podstaw, przykÅ‚ady bÄ™dÄ… <i>â€faÅ‚szyweâ€</i> w maÅ‚ym stopniu.
</p>
<p>
    PrzykÅ‚ady nie majÄ… zamiaru nauczenia jÄ™zyka C - sam jÄ™zyk C zawiera sporo dodatkowej skÅ‚adni, 
    makr oraz sporo funkcji z biblioteki standardowej czy rÃ³wnieÅ¼ sztuki kompilatorÃ³w 
    (jak pozbywanie siÄ™ niepotrzebnych zmiennych). 
    BÄ™dziemy operowaÄ‡ na bardzo prostej skÅ‚adki, krok po kroku.
</p>
<p>
    PrzykÅ‚ady teÅ¼ nie bÄ™dÄ… pokazywaÄ‡ dziaÅ‚anie wspÃ³Å‚czesnych procesorÃ³w - 
    dlatego Å¼e sÄ… <strong> zbyt skomplikowane. </strong> Zacznijmy od podstawowego <i>â€komputeraâ€</i>:
</p>
<p class="center">
    <img src="static/diagrams/cpu_old.svg" width="40%" />
</p>
<p>
    Nasz <i>â€komputerâ€</i> skÅ‚ada siÄ™ z 3 elementÃ³w:
    <ol>
        <li><b>CPU</b> - procesor; jednostka do obliczeÅ„ i rzÄ…dzenia komputerem przez rozkazy</li>
        <li><b>Memory</b> - stÄ…d odczytujemy dane oraz kod do CPU</li>
        <li><b>IO</b> - moÅ¼na rzec â€cokolwiekâ€ co siÄ™ komunikuje - modem, gpu, dysk, diody, czujniki etc.</li>
    </ol>
    Warto teÅ¼ opisaÄ‡ co w sobie ma CPU:
    <ol>
        <li>
            <b>Rejestry</b> - komÃ³rki pamiÄ™ci ktÃ³re sÄ… najbliÅ¼ej dla procesora - 
            dostÄ™p do nich jest najszybszy (kilka cyklÃ³w taktowania zamiast kilkadziesiÄ…t). 
            RÃ³Å¼ne architektury procesorÃ³w majÄ… rÃ³Å¼nÄ… iloÅ›Ä‡ rejestrÃ³w, AVR ma np. 32 rejestry; 
            8086 (z ktÃ³rego wywodzi siÄ™ caÅ‚a rodzina x86, z ktÃ³rego pewnie teraz ty korzystasz),
            posiada zaÅ› 4 rejestry arytmetyczne (do obliczeÅ„) oraz 4 rejestry wskaÅºnikowe (o tym pÃ³Åºniej).
        </li>
        <li>
            <b>Stack Pointer</b> - w skrÃ³cie <b>SP</b>, specjalny rejestr do wskazania na jakiej komÃ³rce pamiÄ™ci jest ostatni element stosu (o stosie bÄ™dzie juÅ¼ za chwilkÄ™, po prostu zapamiÄ™taj Å¼e taki sobie istnieje rejestrik)
        </li>
        <li> 
            <b>Program Counter</b> - w skrÃ³cie <b>PC</b>, specjalny rejestr ktÃ³ry wskazuje jakÄ… komÃ³rkÄ™ ma wykonaÄ‡ procesor jako rozkaz. W naszych przykÅ‚adach Program counter bÄ™dzie wskazywaÄ‡ na linijki naszego kodu (co nie jest do koÅ„ca prawdÄ…, poniewaÅ¼ Program Counter wskazuje na poczÄ…tek rozkazu w pamiÄ™ci, a rozkazy mogÄ… mieÄ‡ rÃ³Å¼ne dÅ‚ugoÅ›ci, ale to juÅ¼ trudniejszy temat.)
        </li>
    </ol>
</p>
<hr />

<p>
    A co zawiera w sobie wspÃ³Å‚czesny procesor?
</p>
<p class="center">
    <img src="static/diagrams/cpu_new.svg" width="40%" />
</p>
<p>
    Dodatkowe elementy takie jak: 
    <ol>
        <li><b>GPU</b> - takie czasy gdy GPU robi lepsze obliczenia niÅ¼ CPU, wiÄ™c moÅ¼e przejÄ…Ä‡ obliczenia</li>
        <li>
            <b>DMA</b> - Direct Memory Access - w starych architekturach dostÄ™p do pamiÄ™ci miaÅ‚ tylko CPU, wiÄ™c jak chcieliÅ›my skopiowaÄ‡ dane z pamiÄ™ci do dysku oraz na odwrÃ³t to musieliÅ›my to robiÄ‡ przez procesor (ktÃ³ry i tak wykonuje inne rzeczy) i to szybkich operacji raczej nie naleÅ¼aÅ‚o, dlatego wymyÅ›lono <b>DMA</b> by dodatkowe urzÄ…dzenia miaÅ‚y bezpoÅ›redni dostÄ™p do pamiÄ™ci - przez co dysk czy GPU nie musi czekaÄ‡ na CPU tylko odrazu dobija siÄ™ do pamiÄ™ci. 
        </li>
    </ol>
    I teraz Procesor:
    <ol>
        <li><b>Cache</b> - bo dostÄ™p do pamiÄ™ci jest zbyt wolny, wiÄ™c CPU wrzuca sobie kawaÅ‚ki kodu by mieÄ‡ szybszy dostÄ™p</li>
        <li><b>Multicore</b> - bo moÅ¼na wykonywaÄ‡ wiele obliczeÅ„ rÃ³wnolegle, no czemu nie!</li>
        <li>Mechanizmy jak <b>Branch Predictor</b> ktÃ³re przewidujÄ… jakie rozkazy bÄ™dÄ… kolejne i juÅ¼ siÄ™ <i>â€przygotowywuje siÄ™â€</i> do ich wykonania</li>
        <li><b>Dodatkowe rejestry</b> Jak np. SIMD - rejestry o bardzo duÅ¼ej dÅ‚ugoÅ›ci ktÃ³re mogÄ… wykonaÄ‡ N obliczeÅ„ naraz (idealnie do przetwarzania muzyki/obrazÃ³w/grafiki 3D)</li>
    </ol>
    MyÅ›lÄ™, Å¼e przekonaÅ‚em CiÄ™, Å¼e nauka na nowszych architekturach nie bÄ™dzie przyjemna na poczÄ…tek.
</p>

<p>
    Ok, ale juÅ¼ koniec z architekturami procesorÃ³w! opowiedzmy sobie jak dziaÅ‚a pamiÄ™Ä‡ w programie.
    Najlepiej sobie wyobraziÄ‡ pamiÄ™Ä‡, Å¼e to jest bardzo duÅ¼a tablica z dwoma kolumnami - adres oraz wartoÅ›Ä‡ 
    (liczba binarna).
    Pod kaÅ¼dy adres mamy komÃ³rkÄ™ pamiÄ™ci (najczÄ™Å›ciej 8 bitÃ³w), i jedynie co procesor moÅ¼e zrobiÄ‡ to aktulizowaÄ‡ wartoÅ›ci pod danymi adresami (symulacja to wyjaÅ›ni bardziej, jeszcze chwilkÄ™!)
</p>
<hr />
<p>
    Program w nowszych procesorach, dostaje przydziaÅ‚ pamiÄ™ci w tzw segmentach - 
    jeÅ¼eli poprosimy o dane z innego obszaru pamiÄ™ci to jÄ…dro systemu grzecznie poinformuje, Å¼e nie mamy dostÄ™pu i <b>wyÅ‚Ä…czy nam program</b>. I uwierz mi - to jest najlepsze co moÅ¼e zrobiÄ‡ dla twojego programu.
</p>
<p>
    Segmenty w naszym programie sÄ… typowo trzy (i do tego potrzebujemy 3 wskaÅºniki):
    <ol>
        <li>
            Segment <b>TEXT</b> albo inaczej nazwany <b>CODE</b> - 
            segment gdzie znajduje siÄ™ nasz kod w postaci maszynowej, zrozumiaÅ‚e dla naszego procesora. 
            W tym miejscu sÄ… nasze funkcje, pÄ™tle etc. ale nie dane.
        </li>
        <li>
            Segment <b>STACK</b> - stos, tutaj wrzucamy nasze tymczasowe zmienne, ktÃ³re nasz kod moÅ¼e modyfikowaÄ‡. Jest to teÅ¼ dobre miejsce dla alokowania dynamicznej pamiÄ™ci.
        </li>
        <li>
            Segment <b>DATA</b> - segment na nasze dane po uruchomieniu programu, tutaj siÄ™ znajdujÄ… globalne oraz statyczne zmienne (dostÄ™pne dla kaÅ¼dej funkcji).
        </li>
    </ol>
    WiÄ™cej tutaj: <a href="https://en.wikipedia.org/wiki/Data_segment">https://en.wikipedia.org/wiki/Data_segment</a>
</p>
<hr />
<p>
    OK! w koÅ„cu dotarliÅ›my do pierwszego przykÅ‚adu: stos. 
    Stos jest tzw. kolejkÄ… FILO - <i>First In, Last Out</i>. Na stos wrzucamy dane (<i>push</i>) oraz wyciÄ…gamy (<i>pop</i>). 
    Jak zauwaÅ¼ycie gÅ‚Ã³wnie to polega na zmienianiu rejestru <b>SP</b> - jest to tak naprawdÄ™ <i>â€licznikâ€</i> ile jest juÅ¼ elementÃ³w oraz wskaÅºnik na kolejny element. Warto teÅ¼ wspomnieÄ‡, Å¼e pamiÄ™Ä‡ siÄ™ nie zeruje - po prostu zmniejszamy wskaÅºnik lub zastÄ™pujemy innymi wartoÅ›ciami.
</p>
<p>
    Nasz przykÅ‚ad jest pseudo-jÄ™zykiem. 
    W przykÅ‚adzie chcemy po kolei wrzuciÄ‡ 3 owoce oraz wrzuciÄ‡ ostatni owoc do rejestru <b>VALUE</b>.
</p>

<div id='stack-fun'></div>
<hr />

<p> Ale to juÅ¼ koniec owocÃ³w - kolejne przykÅ‚ady bÄ™dÄ… operowaÄ‡ na liczbach. LitoÅ›ci zero. </p>

<div id='stack'></div>
{% endblock %}
{% block script %}
<script>
new Example(byId('stack-fun'), [
    { action: 'set $SP 0' ,                    line: 'BEGIN' },
    { action: 'set &$SP ğŸ; add $SP 1',        line: 'push ğŸ' },
    { action: 'set &$SP ğŸŒ; add $SP 1',        line: 'push ğŸŒ' },
    { action: 'set &$SP ğŸ‡; add $SP 1',        line: 'push ğŸ‡' },
    { action: 'set $VALUE ^&$SP-1; sub $SP 1', line: 'pop to VALUE' },
], [ 
    new StackComponent({ pointer: 'SP', start: 0, size: 8 }),
    new CodeComponent(),
], {
    stackSize: 8,
    stackLabels: {
        VALUE: { index: 6, hideAddr: true },
        SP:    { index: 7, hideAddr: true },
    },
    parseVal: function (val) {
        var intVal = parseInt(val);
        return isNaN(intVal) ? val : intVal;
    },
});

new Example(byId('stack'), [
    { action: 'set $SP 0' ,                    line: 'BEGIN' },
    { action: 'set &$SP 111; add $SP 1',       line: 'push 111' },
    { action: 'set &$SP 222; add $SP 1',       line: 'push 222' },
    { action: 'set &$SP 333; add $SP 1',       line: 'push 333' },
    { action: 'set $VALUE ^&$SP-1; sub $SP 1', line: 'pop to VALUE' },
], [ 
    new StackComponent({ pointer: 'SP', start: 0, size: 8 }),
    new CodeComponent(),
], {
    stackSize: 8,
    stackLabels: {
        VALUE: { index: 6, hideAddr: true },
        SP:    { index: 7, hideAddr: true },
    }
});
</script>
{% endblock %}
