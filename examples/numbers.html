{% extends "base.html" %}
{% set title = "Liczby" %}
{% block content %}

<p>
    Tutaj bdzie wyjanione troch o sytemach liczbowych oraz sporo o tym jak liczby si zapisywane i u偶ywane w procesorach.
</p>

<p>
    Najpierw nalezy wyjasni, 偶e zale偶nie od systemu, liczb mo偶na zapisa na wiele sposob贸w.
    Jest ich sporo, we藕my sobie liczb <strong>65</strong> mo偶emy przedstawi jako:
    <table style="{margin: auto;}">
        <tr>
            <td>65</td>
            <td>LXV</td>
            <td>佴佶</td>
        </tr>
        <tr>
            <td><img src="static/babilon.png" /></td>
            <td></td>
            <td>A</td>
        </tr>
        <tr>
            <td>0b1000001</td>
            <td>0x41</td>
            <td>0o101</td>
        </tr>
    </table>
</p>

<p>
    Mamy dwa g贸wne systemy zapis贸w liczb:
    <ul>
        <li>Addytywny - dodajemy elementy do siebie (system jedynkowy, rzymski)</li>
        <li>Pozycyjny - pozycja cyfry w zapisie jest wieloktronoci danej potgi (binarny, arabski, tr贸jkowy zr贸wnowa偶ony)</li>
    </ul>

    Zajmiemy si g贸wnie systemem pozycyjnym.
</p>

<p>
    Ok, dobra, ale jak dziaaj liczby w komputerze?
    Zacznijmy od tego, 偶e mamy generalnie dwa typy liczb w procesorach: zmiennoprzecinkowe (float) oraz cakowite (integer).
</p>

<p>
    Zacznijmy najpierw od dodatnich cakowitych, a tak naprawd od jednego oraz dw贸ch bit贸w by zrozumie jak dziaa zapisywanie oraz dodawanie.
    Bit ma dwie wartoci:
    <ul>
        <li>wysoki (<b>H</b> lub <b>1</b> </li>
        <li>oraz niski (<b>L</b> lub <b>0</b>) </li>
        <li>stosowany w elektronice - wysokiej impedancji - u偶ywa si go gdy wejcie nie jest do niczego podczone </li>
    </ul>
</p>

<p>
    W praktyce mamy 4 "podstawowe" operacje na bitach:
    <ul>
        <li><b>OR</b>  (lub) - jak kt贸ry bit jest <b>1</b> to wynik wynosi <b>1</b>, w przeciwnym przypadku <b>0</b></li>
        <li><b>NOT</b> (negacja, inwersja) - odwraca bit</li>
        <li><b>AND</b> (i) - jak kt贸ry bit jest <b>0</b> to wynik wynosi <b>0</b>, w przeciwnym przypadku <b>1</b></li>
        <li><b>XOR</b> (alternatywa) - je偶eli dwa bity si r贸偶ni, to wynik wynosi <b>1</b>, w przeciwnym przypadku <b>0</b></li>
    </ul>

</p>

<p>
    Sam procesor robi ju偶 operacje na rejestrach - czyli licie bit贸w. To jest wa偶ne, by nie patrze na rejestr jako liczb a raczej jako "stan". Taki sam stan bit贸w mo偶e oznacza calkowicie inn warto - wszystko zale偶y jak j zinterpretujemy.
</p>

<p>
    Za贸偶my,偶e mamy procesor kt贸ry operuje na 4bitowych sowach - takowe nie istniej, ale pomog zrozumie dziaanie.
</p>

<div id="logic-operators"></div>

<p>
    Ok, jak ju偶 rozumiemy podstawowe operacje, to czas przej jak dziaa dodawanie. Najpierw troch matematyki w systemie binarnym:

    <ul>
        <li>x + y = cs</li>
        <li>0 + 0 = 00</li>
        <li>1 + 0 = 01</li>
        <li>0 + 1 = 01</li>
        <li>1 + 1 = 10</li>
    </ul>

    Je偶eli to rozbijemy na dwa osobne bity:

    <ul>
        <li>x + y = s</li>
        <li>0 + 0 = 0</li>
        <li>1 + 0 = 1</li>
        <li>0 + 1 = 1</li>
        <li>1 + 1 = 0</li>
    </ul>
    <ul>
        <li>x + y = c</li>
        <li>0 + 0 = 0</li>
        <li>1 + 0 = 0</li>
        <li>0 + 1 = 0</li>
        <li>1 + 1 = 1</li>
    </ul>

    To wychodz nam dwie funkcje:
    <ul>
        <li>s = XOR(x, y)</li>
        <li>c = AND(x, y)</li>
    </ul>

    Gratulacje - zrobilimy ukad zwany <i>p贸 sumatorem (half-adder)</i>,
    kt贸ry ma dwa bity wyjcia - wynik dodawania (s, od <i>sum</i>) oraz bit przenony (c, od <i>carry</i>).
    metoda przypomina bardzo dodawanie w supku (mielimy takie co w szkole podstawowej, tak napewno byo, a p贸藕niej odkrylimy kalkulatory)
</p>

<p> Czas na peny sumator: </p>

<img src="static/adder.png" />

<p>
    R贸偶nica midzy p贸 a penym sumatorem jest taka, 偶e doszed trzeci argument - carry z poprzedniego bitu (wci偶 nas przeladuje dodawanie w supku).
    Przy pomocy N sumator贸w mo偶emy dodawa liczby N bitowe. czyli do typu <b>int</b>, kt贸ry ma 32 bity, potrzebujemy w procesorze 32 sumatory.
</p>

<p>
    Ok, jak ju偶 ogarniamy sumatory i bit przenony (carry), to mo偶emy dodawa liczby:
</p>

<div id="add-1"></div>

<p>
    Co si stao w linijce 3? wystapio przepenienie rejestru - w tej linijce zrobilimy operacj 12 + 4 = 16, do kt贸rego potrzebujemy 5 bit贸w, a nasz procesorek ma tylko 4 bity. Ale nie jest 藕le - bo ustawia si flaga CARRY w procesorze kt贸ra informuje, 偶e przy dodawaniu ostatni bit mia przeniesienie.
</p>

<p>
Niestety ze wgldu, 偶e liczby cakowite s w stanie si przekrci jak licznik w samochodzie, mo偶e doprowadzi do niefajnych bd贸w jak np. w grze Civilization1 - poziom agresji by zapisywany w 1 bajcie (8bit贸w). Gandhi jako wadca dawa 1 poziom agresji. Jezeli wybrao sie ustr贸j demokracja kt贸ra obni偶aa poziom agresji to poziom si przekrca z 1 - 2 = 255 (przekrcilmy w drug stron, 255 to najwiksza 8bitowa warto) co doprowadzao automatycznie do wojny atomowej (sic!) - wicej <a href="https://civilization.fandom.com/wiki/Mohandas_Gandhi_(Civ1)">Tutaj</a>
</p>

<p> tak samo dziao si w grze pacman - gdy przeszo si poziom 255 mia nastpi poziom 256, ale ze wzgldu na 8 bit贸w przesun sie na poziom 0. I ze wzgldu na warunek <strong>for(i=1; i != LEVEL; i++)</strong> doprowadzao do zgliczowania <a href="https://pacman.fandom.com/wiki/Map_256_Glitch">mapy</a> </p>

<p> Mo偶emy wykorzysta flag CARRY, jezeli chcemy w naszym 4bitowym procesorku zrobi operacji 8 bitowe. W poni偶szym przykadzie zrobimy w pseudo-ASM sum 0x8 + 0x88 (8 bitowej). U偶yjemy tutaj rozkazu ADD oraz ADC (Add with Carry) </p>

<div id="add-2"></div>

<p>
    Jak dotrwalicie do koca - to pewnie zauwa偶ylicie, 偶e dodatkowy bit z operacji z 1 linijki, przeni贸s si do operacji z 2 linijki.
</p>

<p>
    Pojawi si te偶 problem - tera藕niejsze procesory potrafi operowa na rejestrach 8bitowych, 16bitowych, 32 oraz 64 (oraz wiksze ale to ju偶 inny temat). I teraz - w jakiej kolejnoci zapisywa kolejne kom贸rki pamici? Od najwy偶szego bajtu czy od najni偶szego?
</p>

<p>
    Odpowied藕 to <b>zale偶y</b>. Mamy dwa kolejnoci - Big Endian (pierwszy jest zapisywany najwy偶szy bajt) oraz Little Endian (zapisywany najni偶szy bajt jako pierwszy). S r贸偶ne formaty plik贸w oraz r贸偶ne procesory kt贸re obsuguj taki zapis lub taki zapis. My jednak przyjmiemy zapis Little Endian bo tak w tej chwili dziaaj najpopularniejsze procesory (czyli x86, AVR czy ARM)
</p>

<img src="static/endian.png" />

<p> Ok, a co z liczbami ujemnymi? </p>

{% endblock %}
{% block script %}
<script>
    new Example(byId('logic-operators'), [
        { action: 'set $X 5; set $Y 3',          line: 'uint4 x = 0x5, y = 0x3;' },
        { action: 'set $NEG &$X; neg4 $NEG',     line: 'uint4 neg = ~x;' },
        { action: 'set $OR &$X;  or4 $OR &$Y',   line: 'uint4 or = x | y;' },
        { action: 'set $AND &$X; and4 $AND &$Y', line: 'uint4 and = x & y;' },
        { action: 'set $XOR &$X; xor4 $XOR &$Y', line: 'uint4 xor = x ^ y;' },
        { action: 'nop', line: ''},
    ], [
        new StackComponent({ start: 0, size: 8 }),
        new CodeComponent(),
    ], {
        availableFlags: CpuFlags,
        stackSize: 8,
        stackLabels: {
            X:   { index: 0, render: ['bit4', 'hex'] },
            Y:   { index: 1, render: ['bit4', 'hex'] },
            NEG: { index: 2, render: ['bit4', 'hex'] },
            OR:  { index: 3, render: ['bit4', 'hex'] },
            AND: { index: 4, render: ['bit4', 'hex'] },
            XOR: { index: 5, render: ['bit4', 'hex'] },
        }
    });
    new Example(byId('add-1'), [
        { action: 'set4 $A 0',          line: 'uint4 a = 0x0;' },
        { action: 'add4 $A 10',         line: 'a += 0xA;' },
        { action: 'add4 $A 2',          line: 'a += 0x2;' },
        { action: 'add4 $A 4',          line: 'a += 0x4;' },
        { action: 'nop', line: ''},
    ], [
        new StackComponent({ start: 0, size: 8 }),
        new FlagsComponent(),
        new CodeComponent(),
    ], {
        availableFlags: CpuFlags,
        stackSize: 8,
        stackLabels: {
            A:   { index: 0, render: ['bit4', 'hex'] },
        }
    });
    new Example(byId('add-2'), [
        { action: 'set4 $A 8; set4 $B 0', line: 'SET A 0x8; SET B 0x0' },
        { action: 'add4 $A 8',            line: 'ADD A 0x8;' },
        { action: 'adc4 $B 8',            line: 'ADC B 0x8;' },
        { action: 'nop', line: ''},
    ], [
        new StackComponent({ start: 0, size: 8 }),
        new FlagsComponent(),
        new CodeComponent(),
    ], {
        availableFlags: CpuFlags,
        stackSize: 8,
        stackLabels: {
            A:   { index: 0, render: ['bit4', 'hex'] },
            B:   { index: 1, render: ['bit4', 'hex'] },
        }
    });
</script>
{% endblock %}
