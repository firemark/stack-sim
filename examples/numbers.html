{% extends "base.html" %}
{% set title = "Liczby" %}
{% block content %}

<p>
    Tutaj bÄ™dzie wyjaÅ›nione trochÄ™ o sytemach liczbowych oraz sporo o tym jak liczby siÄ™ zapisywane i uÅ¼ywane w procesorach.
</p>

<p>
    Najpierw nalezy wyjasniÄ‡, Å¼e zaleÅ¼nie od systemu, liczbÄ™ moÅ¼na zapisaÄ‡ na wiele sposobÃ³w.
    Jest ich sporo, weÅºmy sobie liczbÄ™ <em>65</em> moÅ¼emy przedstawiÄ‡ jako:
    <div class="center-block">
        <table class="table table-center">
            <tr>
                <td>65</td>
                <td>LXV</td>
                <td>Ù¦Ù¥</td>
            </tr>
            <tr>
                <td>0b1000001</td>
                <td>0x41</td>
                <td>0o101</td>
            </tr>
            <tr>
                <td><img src="static/babilon.png" /></td>
                <td>ğŸ</td>
                <td>A</td>
            </tr>
        </table>
    </div>
</p>

<p>
    Mamy dwa gÅ‚Ã³wne systemy zapisÃ³w liczb:
    <ul>
        <li>Addytywny - dodajemy elementy do siebie (system jedynkowy, rzymski)</li>
        <li>Pozycyjny - pozycja cyfry w zapisie jest wieloktronoÅ›ciÄ… danej potÄ™gi (binarny, arabski, trÃ³jkowy zrÃ³wnowaÅ¼ony)</li>
    </ul>

    Zajmiemy siÄ™ gÅ‚Ã³wnie systemem pozycyjnym.
</p>

<p>
    Ok, dobra, ale jak dziaÅ‚ajÄ… liczby w komputerze?
    Zacznijmy od tego, Å¼e mamy generalnie dwa typy liczb w procesorach: zmiennoprzecinkowe (float) oraz caÅ‚kowite (integer).
</p>

<p>
    Zacznijmy najpierw od dodatnich caÅ‚kowitych, a tak naprawdÄ™ od jednego oraz dwÃ³ch bitÃ³w by zrozumieÄ‡ jak dziaÅ‚a zapisywanie oraz dodawanie.
    Bit ma dwie wartoÅ›ci:
    <ul>
        <li>wysoki (<b>H</b> lub <b>1</b>) </li>
        <li>oraz niski (<b>L</b> lub <b>0</b>) </li>
        <li>stosowany w elektronice - wysokiej impedancji - uÅ¼ywa siÄ™ go gdy wejÅ›cie nie jest do niczego podÅ‚Ä…czone </li>
    </ul>
</p>

<p>
    W praktyce mamy 4 "podstawowe" operacje na bitach:
    <ul>
        <li><b>OR</b>  (lub) - jak ktÃ³ryÅ› bit jest <b>1</b> to wynik wynosi <b>1</b>, w przeciwnym przypadku <b>0</b></li>
        <li><b>NOT</b> (negacja, inwersja) - odwraca bit</li>
        <li><b>AND</b> (i) - jak ktÃ³ryÅ› bit jest <b>0</b> to wynik wynosi <b>0</b>, w przeciwnym przypadku <b>1</b></li>
        <li><b>XOR</b> (alternatywa) - jeÅ¼eli dwa bity siÄ™ rÃ³Å¼niÄ…, to wynik wynosi <b>1</b>, w przeciwnym przypadku <b>0</b></li>
    </ul>

</p>

<p>
    Sam procesor robi juÅ¼ operacje na rejestrach - czyli liÅ›cie bitÃ³w. To jest waÅ¼ne, by nie patrzeÄ‡ na rejestr jako liczbÄ™ a raczej jako "stan". Taki sam stan bitÃ³w moÅ¼e oznaczaÄ‡ calkowicie innÄ… wartoÅ›Ä‡ - wszystko zaleÅ¼y jak jÄ… zinterpretujemy.
</p>

<p>
    ZaÅ‚Ã³Å¼my,Â Å¼e mamy procesor ktÃ³ry operuje na 4bitowych sÅ‚owach - takowe nie istniejÄ…, ale pomogÄ… zrozumieÄ‡ dziaÅ‚anie.
</p>

<div id="logic-operators"></div>

<p>
    Ok, jak juÅ¼ rozumiemy podstawowe operacje, czas zrozumieÄ‡ jak moÅ¼emy zapisaÄ‡ liczbÄ™. Przypomnijmy sobie jak wyglÄ…da to w systemie dziesiÄ™tnym:
    <br /><br />
    <em>
        1023<small>(10)</small>
        = 1Â·10Â³ + 0Â·10Â² + 2Â·10Â¹ + 3Â·10â°
    </em>
    <br /><br />
    Tak samo moÅ¼emy zapisac binarnie liczby, tylko zamiast liczb 0-9 oraz podstawy 10, bÄ™dziemy mieÄ‡ liczby 0-1 oraz podstawÄ™ 2:
    <br /><br />
    <em>
        1010<small>(2)</small>
        = 1Â·2Â³ + 0Â·2Â² + 1Â·2Â¹ + 0Â·2â° = 1Â·8 + 0Â·4 + 1Â·2 + 0Â·1 = 8 + 2
        = 10<small>(10)</small>
    </em>
</p>

<p>
     To czas przejÅ›Ä‡ jak dziaÅ‚a dodawanie. Najpierw trochÄ™ matematyki w systemie binarnym
     <a href="https://eduinf.waw.pl/inf/alg/006_bin/0010.php">(wiÄ™cej tutaj o liczbach)</a>:

    <ul>
        <li>x + y = cs</li>
        <li>0 + 0 = 00</li>
        <li>1 + 0 = 01</li>
        <li>0 + 1 = 01</li>
        <li>1 + 1 = 10</li>
    </ul>

    JeÅ¼eli to rozbijemy na dwa osobne bity:

    <ul>
        <li>x + y = s</li>
        <li>0 + 0 = 0</li>
        <li>1 + 0 = 1</li>
        <li>0 + 1 = 1</li>
        <li>1 + 1 = 0</li>
    </ul>
    <ul>
        <li>x + y = c</li>
        <li>0 + 0 = 0</li>
        <li>1 + 0 = 0</li>
        <li>0 + 1 = 0</li>
        <li>1 + 1 = 1</li>
    </ul>

    To wychodzÄ… nam dwie funkcje:
    <ul>
        <li>s = XOR(x, y)</li>
        <li>c = AND(x, y)</li>
    </ul>

    Gratulacje - zrobiliÅ›my ukÅ‚ad zwany <i>pÃ³Å‚ sumatorem (half-adder)</i>,
    ktÃ³ry ma dwa bity wyjÅ›cia - wynik dodawania (s, od <i>sum</i>) oraz bit przenoÅ›ny (c, od <i>carry</i>).
    metoda przypomina bardzo dodawanie w sÅ‚upku (mieliÅ›my takie coÅ› w szkole podstawowej, tak napewno byÅ‚o, a pÃ³Åºniej odkryliÅ›my kalkulatory)
</p>

<p> Czas na peÅ‚ny sumator: </p>

<img src="static/adder.png" />

<p>
    RÃ³Å¼nica miÄ™dzy pÃ³Å‚ a peÅ‚nym sumatorem jest taka, Å¼e doszedÅ‚ trzeci argument - carry z poprzedniego bitu (wciÄ…Å¼ nas przeÅ›laduje dodawanie w sÅ‚upku).
    Przy pomocy N sumatorÃ³w moÅ¼emy dodawaÄ‡ liczby N bitowe. czyli do typu <b>int</b>, ktÃ³ry ma 32 bity, potrzebujemy w procesorze 32 sumatory.
</p>

<p>
    Ok, jak juÅ¼ ogarniamy sumatory i bit przenoÅ›ny (carry), to moÅ¼emy dodawaÄ‡ liczby:
</p>

<div id="add-1"></div>

<p>
    Co siÄ™ staÅ‚o w linijce 3? wystapiÅ‚o przepeÅ‚nienie rejestru - w tej linijce zrobiliÅ›my operacjÄ™ 12 + 4 = 16, do ktÃ³rego potrzebujemy 5 bitÃ³w, a nasz procesorek ma tylko 4 bity. Ale nie jest Åºle - bo ustawiÅ‚a siÄ™ flaga CARRY w procesorze ktÃ³ra informuje, Å¼e przy dodawaniu ostatni bit miaÅ‚ przeniesienie.
</p>

<p>
Niestety ze wglÄ™du, Å¼e liczby caÅ‚kowite sÄ… w stanie siÄ™ przekrÄ™ciÄ‡ jak licznik w samochodzie, moÅ¼e doprowadziÄ‡ do niefajnych bÅ‚Ä™dÃ³w jak np. w grze Civilization1 - poziom agresji byÅ‚ zapisywany w 1 bajcie (8bitÃ³w). Gandhi jako wÅ‚adca dawaÅ‚ 1 poziom agresji. Jezeli wybraÅ‚o sie ustrÃ³j demokracja ktÃ³ra obniÅ¼aÅ‚a poziom agresji to poziom siÄ™ przekrÄ™caÅ‚ z 1 - 2 = 255 (przekrÄ™cilÅ›my w drugÄ… stronÄ™, 255 to najwiÄ™ksza 8bitowa wartoÅ›Ä‡) co doprowadzaÅ‚o automatycznie do wojny atomowej (sic!) - wiÄ™cej <a href="https://civilization.fandom.com/wiki/Mohandas_Gandhi_(Civ1)">Tutaj</a>
</p>

<p> tak samo dziaÅ‚o siÄ™ w grze pacman - gdy przeszÅ‚o siÄ™ poziom 255 miaÅ‚ nastÄ…piÄ‡ poziom 256, ale ze wzglÄ™du na 8 bitÃ³w przesunÄ…Å‚ sie na poziom 0. I ze wzglÄ™du na warunek <strong>for(i=1; i != LEVEL; i++)</strong> doprowadzaÅ‚o do zgliczowania <a href="https://pacman.fandom.com/wiki/Map_256_Glitch">mapy</a> </p>

<p> MoÅ¼emy wykorzystaÄ‡ flagÄ™ CARRY, jezeli chcemy w naszym 4bitowym procesorku zrobiÄ‡ operacji 8 bitowe. W poniÅ¼szym przykÅ‚adzie zrobimy w pseudo-ASM sumÄ™ 0x8 + 0x88 (8 bitowej). UÅ¼yjemy tutaj rozkazu ADD oraz ADC (Add with Carry) </p>

<div id="add-2"></div>

<p>
    Jak dotrwaliÅ›cie do koÅ„ca - to pewnie zauwaÅ¼yliÅ›cie, Å¼e dodatkowy bit z operacji z 1 linijki, przeniÃ³sÅ‚ siÄ™ do operacji z 2 linijki.
</p>

<p>
    PojawiÅ‚ siÄ™ teÅ¼ problem - teraÅºniejsze procesory potrafiÄ… operowaÄ‡ na rejestrach 8bitowych, 16bitowych, 32 oraz 64 (oraz wiÄ™ksze ale to juÅ¼ inny temat). I teraz - w jakiej kolejnoÅ›ci zapisywaÄ‡ kolejne komÃ³rki pamiÄ™ci? Od najwyÅ¼szego bajtu czy od najniÅ¼szego?
</p>

<p>
    OdpowiedÅº to <b>zaleÅ¼y</b>. Mamy dwa kolejnoÅ›ci - Big Endian (pierwszy jest zapisywany najwyÅ¼szy bajt) oraz Little Endian (zapisywany najniÅ¼szy bajt jako pierwszy). SÄ… rÃ³Å¼ne formaty plikÃ³w oraz rÃ³Å¼ne procesory ktÃ³re obsÅ‚ugujÄ… taki zapis lub taki zapis. My jednak przyjmiemy zapis Little Endian bo tak w tej chwili dziaÅ‚ajÄ… najpopularniejsze procesory (czyli x86, AVR czy ARM)
</p>

<img src="static/endian.png" />

<p> Ok, a co z liczbami ujemnymi? </p>

<p>
    SposobÃ³w sÄ… kilka, najpopularniejszy dla liczb caÅ‚kowitych jest zapis 2C (U2):
    <ol>
        <li>Najstarszy bit jest bitem znaku (<b>0</b> to dodatnia, <b>1</b> to ujemna)</li>
        <li>Najstarszy bit ma wagÄ™ -2â¿â»Â¹</li>
        <li>PozostaÅ‚e bity sÄ… liczone jak w poprzednim systemie</li>
        <li>OdwrÃ³cenie znaku robi siÄ™ przez inwersjÄ™ wszystkich bitÃ³w i odjÄ™cie 1</li>
        <li>Dodawanie oraz odejmowanie liczy siÄ™ tak samo jak w systemie nieznakowym</li>
        <li><a href="https://eduinf.waw.pl/inf/alg/006_bin/0018.php">WiÄ™cej tutaj</a>
    </ol>
</p>

<p>
    MoÅ¼emy porÃ³wnaÄ‡ dwa systemy - nieznakowy oraz U2 (istniejÄ… jeszcze inne ale to jest temat przy piwie)

    <div class="center-block">
        <table class="table table-center">
            <tr>
                <th>Bity</th>
                <th>Beznakowy</th>
                <th>U2</th>
            </tr>
            <tr>
                <td>0000</td>
                <td>0</td>
                <td>0</td>
            </tr>
            <tr>
                <td>0001</td>
                <td>1</td>
                <td>1</td>
            </tr>
            <tr>
                <td>0010</td>
                <td>2</td>
                <td>2</td>
            </tr>
            <tr>
                <td>â€¦</td>
                <td>â€¦</td>
                <td>â€¦</td>
            </tr>
            <tr>
                <td>0111</td>
                <td>7</td>
                <td>7</td>
            </tr>
            <tr>
                <td>1000</td>
                <td>8</td>
                <td>-8</td>
            </tr>
            <tr>
                <td>1001</td>
                <td>9</td>
                <td>-7</td>
            </tr>
            <tr>
                <td>â€¦</td>
                <td>â€¦</td>
                <td>â€¦</td>
            </tr>
            <tr>
                <td>1110</td>
                <td>14</td>
                <td>-2</td>
            </tr>
            <tr>
                <td>1111</td>
                <td>15</td>
                <td>-1</td>
            </tr>
        </table>
    </div>
</p>

<p> No to przykÅ‚adzik: </p>

<div id="add-3"></div>

<p>
    Podobnie jak w systemie bezznakowym przekrÄ™cenie licznika jest kosztowne - w grze Transport Tycoon (dziadek OpenTTD) byÅ‚a moÅ¼liwoÅ›Ä‡ stworzenia tak dÅ‚ugiego mostu, Å¼e koszt byÅ‚ tak duÅ¼y (16bitowy znakowy), Å¼e zmieniaÅ‚ siÄ™ znak i cena budowy byÅ‚a ujemna :-).
</p>

{% endblock %}
{% block script %}
<script>
    new Example(byId('logic-operators'), [
        { action: 'set $X 5; set $Y 3',          line: 'uint4 x = 0x5, y = 0x3;' },
        { action: 'set $NEG &$X; neg4 $NEG',     line: 'uint4 neg = ~x;' },
        { action: 'set $OR &$X;  or4 $OR &$Y',   line: 'uint4 or = x | y;' },
        { action: 'set $AND &$X; and4 $AND &$Y', line: 'uint4 and = x & y;' },
        { action: 'set $XOR &$X; xor4 $XOR &$Y', line: 'uint4 xor = x ^ y;' },
        { action: 'nop', line: ''},
    ], [
        new StackComponent({ start: 0, size: 8 }),
        new CodeComponent(),
    ], {
        availableFlags: CpuFlags,
        stackSize: 8,
        stackLabels: {
            X:   { index: 0, render: ['bit4', 'dec_u8'] },
            Y:   { index: 1, render: ['bit4', 'dec_u8'] },
            NEG: { index: 2, render: ['bit4', 'dec_u8'] },
            OR:  { index: 3, render: ['bit4', 'dec_u8'] },
            AND: { index: 4, render: ['bit4', 'dec_u8'] },
            XOR: { index: 5, render: ['bit4', 'dec_u8'] },
        }
    });
    new Example(byId('add-1'), [
        { action: 'set4 $A 0',          line: 'uint4 a = 0x0;' },
        { action: 'add4 $A 10',         line: 'a += 0xA;' },
        { action: 'add4 $A 2',          line: 'a += 0x2;' },
        { action: 'add4 $A 4',          line: 'a += 0x4;' },
        { action: 'nop', line: ''},
    ], [
        new StackComponent({ start: 0, size: 8 }),
        new FlagsComponent(),
        new CodeComponent(),
    ], {
        availableFlags: CpuFlags,
        stackSize: 8,
        stackLabels: {
            A:   { index: 0, render: ['bit4', 'dec_u8'] },
        }
    });
    new Example(byId('add-2'), [
        { action: 'set4 $A 8; set4 $B 0', line: 'SET A 0x8; SET B 0x0' },
        { action: 'add4 $A 8',            line: 'ADD A 0x8;' },
        { action: 'adc4 $B 8',            line: 'ADC B 0x8;' },
        { action: 'nop', line: ''},
    ], [
        new StackComponent({ start: 0, size: 8 }),
        new FlagsComponent(),
        new CodeComponent(),
    ], {
        availableFlags: CpuFlags,
        stackSize: 8,
        stackLabels: {
            A:   { index: 0, render: ['bit4', 'dec_u8'] },
            B:   { index: 1, render: ['bit4', 'dec_u8'] },
        }
    });
    new Example(byId('add-3'), [
        { action: 'set8 $A 255',        line: 'unsigned char a = 0xFF;' },
        { action: 'set8 $B &$A',        line: 'char b = a;' },
        { action: 'nop', line: ''},
    ], [
        new StackComponent({ start: 0, size: 8 }),
        new FlagsComponent(),
        new CodeComponent(),
    ], {
        availableFlags: CpuFlags,
        stackSize: 8,
        stackLabels: {
            A:   { index: 0, render: ['bit8', 'dec_u8'] },
            B:   { index: 1, render: ['bit8', 'dec_s8'] },
        }
    });
</script>
{% endblock %}
